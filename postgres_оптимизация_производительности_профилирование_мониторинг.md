## Оптимизация производительности. Профилирование. Мониторинг.

[К оглавлению...](/README.md)

Анализ БД
Почему тупит?

- ресурсы проверить (cpu, ram, disk)
- посмотреть долгие запросы
- посмотреть индексы
- `vacuum analise` (postgres анализирует данные, после чего планировщик строит более оптимальные запросы)
- `explain` тупящих запросов
- посмотреть последние миграции и последние commit-ы
- найти самый большой запрос и убить если можно (`pg_stat_activity`)
    - загуглить как найти, как убить
- коннекты в состоянии `idle` (запрос выполнен, но коннект висит) - если больше 100 (по умолчанию) - то пздц
    - хуже всего состояние `idle in transactions` - запрос висит и ожидает выполнения другого запроса (блокировка)
- снять повисшие транзакции (влияет на анализатор, wall файлы и др...)
- `pg_stat_statements` - можно посмотреть уже выполненные долгие запросы

---

Представление pg_stat_user_tables - тут можно посмотреть данные про таблицу, например сколько раз из таблицы данные
читались последовательно или с помощью индекса, когда проводился автовакум, вакум аналайз и прочее.

```sql
select * from pg_stat_user_tables;
```

Если много нулей - значит нет стастики - нужен аналайз

Важные поля

- **seq_scan** — количество последовательных сканирований таблицы. Последовательное сканирование — это чтение таблицы от
  начала до конца, поскольку таблица очень мала или отсутствуют индексы, которые могли бы эффективно удовлетворить
  критериям фильтра. Последовательное сканирование, вероятно, является самой дорогостоящей операцией, которую выполняет
  сервер базы данных, однако некоторые из них неизбежны. Если правильная индексация не может устранить необходимость
  последовательного сканирования таблицы, крайне важно, чтобы конфигурация PostrgeSQL предоставляла достаточно ресурсов
  для поддержания высокой скорости кэширования.
- **seq_tup_read** — количество строк, обработанных при последовательном сканировании. Это не количество записей,
  возвращенных
  приложениям в качестве результатов, а количество записей, обработанных для создания набора результатов, что, вероятно,
  составляет значительную часть этого числа. Например, если запрос возвращает десять записей, но требует
  последовательного
  сканирования таблицы, то это значение увеличится на количество записей в таблице, а не на десять.

---
настройки postgres

```sql
select * from pg_settings;
``` 

Лучше посмотреть конфигураторы где-нибудь в сети - там будут полезные советы
- pgconfigurator.cybertec.at
- pgtune - тут можно задать исходные данные и онлайн-сервис предложит оптимальные настройки

Рекомендуется менять конфиги postgres через ALTER вместо того, чтобы менять конфиг, чтобы не случайно не испортить
дефолтные настройки postgres

---

Дополнительно

- Postgres очень не любит windows и любит linux (файловая система не оптимальна, доступ к ядру ОС)
- `WALL` файлы лучше хранить на отдельных дисках
- если загрузка cpu больше 70 процентов и ядра загружены равномерно - значит не хватает ресурсов
- загуглить про hugo pages
- загуглить про transparent hugo page
- `swappiness` - когда не хватает RAM (оперативки), система начинает лезть в диски (они медленнее, чем RAM)
    - частота сброса данных из RAM в SWAP - рекомендуется от 1 до 5
- иметь grafana + prometheus
- postgres не любит делиться оперативкой и другими ресурсами - не ставить рядом с посгрей на одном сервере другие
  приложения

ОСТАНОВИЛСЯ НА 48 МИНУТЕ
