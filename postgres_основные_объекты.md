## Основные объекты в Postgres

[К оглавлению...](/README.md)

- Кластер
  - Табличное пространство
  - Роль (пользователь)
  - База данных
    - Схема
      - Таблица
        - Индекс
      - Материализованное представление
      - Последовательность
      - Функция, процедура
      - Представление

### Кластер Postgres

**Кластер PostgreSQL** - это группа серверов PostgreSQL, которые работают вместе для обеспечения высокой доступности,
масштабируемости и отказоустойчивости базы данных.

Кластер состоит из одного главного сервера - **мастера** и одного или нескольких вспомогательных серверов - **реплики**.
Главный сервер принимает все запросы на запись и чтение, а реплики служат для распределения нагрузки и обеспечения
доступности базы данных.

В кластере PostgreSQL данные автоматически реплицируются на все реплики.

Кластер PostgreSQL может быть настроен для работы в разных режимах репликации, таких как **многомастерная репликация** и
**мастер-репликация**. В многомастерной репликации все серверы могут принимать запросы на запись, а в мастер-репликации
только главный сервер может принимать запросы на запись.

Кластер PostgreSQL также может быть настроен для распределения нагрузки между серверами. Это может улучшить
производительность базы данных, так как запросы могут быть распределены на несколько серверов.

**Pg_cluster** предоставляет следующие возможности для управления кластером PostgreSQL:

- **Управление кластером**: Pg_cluster позволяет легко создавать, изменять и удалять кластеры PostgreSQL. Вы можете
  настроить параметры кластера, такие как количество узлов, настройки репликации, сетевые интерфейсы и многое другое.
- **Управление узлами**: Pg_cluster предоставляет возможность управления узлами кластера PostgreSQL. Вы можете
  запускать, останавливать и перезапускать узлы, а также просматривать статус узлов и логи.
- **Мониторинг**: Pg_cluster позволяет отслеживать работу кластера PostgreSQL, предоставляя информацию о нагрузке на
  узлы, производительности базы данных и статусе репликации.
- **Резервное копирование и восстановление**: Pg_cluster позволяет создавать резервные копии кластера PostgreSQL и
  восстанавливать их в случае сбоя. Вы можете выбирать, какие данные сохранять в резервных копиях и как часто их
  создавать.
- **Репликация**: Pg_cluster позволяет настроить репликацию кластера PostgreSQL. Вы можете выбрать режим репликации и
  настроить параметры репликации для обеспечения высокой доступности и масштабируемости.

При установке кластера PostgreSQL создаются 3 базы данных:

- **template0** - это системный шаблон на основе которого создаются все новые базы данных. Это чистый шаблон и не должен
  быть изменен
- **template1** - шаблоном, который можно изменять. Он имеет ту же структуру, что и _template0_, но в него можно
  добавлять расширения и настройки, которые будут применяться в каждой новой базе данных, созданной на его основе.
  Создание базы данных сводится к копированию шаблона
- **postgres** - это системный шаблон, к которому изначально можно подключиться

### Табличные пространства

[ссылка на PostgresPro](https://postgrespro.ru/docs/postgresql/13/sql-createtablespace)

Табличные пространства определяют физическое размещение данных в файловой системе

```sql
CREATE TABLESPACE табл_пространство
[ OWNER { новый_владелец | CURRENT_USER | SESSION_USER } ]
LOCATION 'каталог’
[ WITH ( параметр_табличного_пространства = значение [, ... ] ) ]
```

Каталог, который будет использован для этого табличного пространства должен уже существовать. Объекты одной базы данных
могут быть размещены в нескольких табличных пространствах В одном табличном пространстве могут быть размещены объекты
нескольких баз данных.

При установке кластера создаются два табличных пространства:

- `pg_default` – используется по умолчанию при создании объектов БД (если не было задано другое ТС по умолчанию).
- `pg_global` – в этом ТС размещаются объекты, общие для всего кластера.

### Схемы

[ссылка на PostgresPro](https://postgrespro.ru/docs/postgresql/13/ddl-schemas)

**Схема** – это логический контейнер, который содержит наборы таблиц, представлений (view), функций, типов данных и
других объектов базы данных. Он позволяет организовать базу данных на более высоком уровне абстракции, чтобы упростить
управление ею.

Схема принадлежит конкретной базе данных. При создании базы данных создаются схемы:

- **public** - это схема по умолчанию в PostgreSQL, которая содержит все объекты, созданные без указания схемы
- **pg_catalog** - это системная схема, которая содержит системные таблицы и функции
- **information_schema** - это схема, которая содержит представления, отображающие метаданные объектов базы данных,
  такие как таблицы, столбцы, ограничения, индексы и другие объекты

### Таблицы

[Обычные таблицы - ссылка на PostgresPro](https://postgrespro.ru/docs/postgresql/13/sql-createtable)

**Временные таблицы** в PostgreSQL - это специальный тип таблиц, который существует только во время сеанса соединения с
базой данных и автоматически удаляется после закрытия соединения

- Существуют только в пределах одной сессии соединения с базой данных и автоматически удаляются после закрытия сессии
  или транзакции.
- Имена временных таблиц начинаются с префикса "`temp`_" или "`pg_temp`_".
- Могут быть созданы как локальные (`local`) - доступны только в рамках текущей транзакции, так и глобальные (`global`)
  Глобальные доступны для всех сессий соединения с базой данных.
- При использовании временных таблиц в SQL запросах не нужно указывать схему (`schema`) и базу данных, так как они
  автоматически ассоциируются с текущей сессией.

```sql
CREATE TEMPORARY TABLE temp_table (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  age INTEGER
);
```

Использование временных таблиц может помочь оптимизировать производительность и снизить нагрузку на базу данных,
особенно в случаях, когда требуется обработка больших объемов данных.

У таблицы можно быстро изменить схему, а табличное пространство будет меняться долго, так как происходит фактическое
копирование данных

### Секционированные таблицы

Секционирование таблиц в PostgreSQL - это разбиение большой таблицы на более мелкие части (разделы), чтобы управлять
данными проще и быстрее.

Виды секционирования

- **Секционирование по диапазону** (Range partitioning): при таком секционировании таблица разбивается на разделы,
  основываясь на диапазоне значений определенного столбца. Например, можно разбить таблицу по диапазону дат или чисел

- Плюсы:
  - Ускоряет выполнение запросов, которые используют диапазон значений;
- Минусы:
  - Может возникнуть проблема сбалансированности разделов, если данные не распределены равномерно по диапазонам.

- **Секционирование по списку** (List partitioning): при таком секционировании таблица разбивается на разделы,
  основываясь на списке значений определенного столбца. Например, можно разбить таблицу по списку имен пользователей или
  категорий товаров

- Плюсы:
  - Удобен для разбиения данных по категориям или набору значений;
  - Позволяет быстро находить данные, соответствующие определенному списку значений;
  - Можно использовать индексы для каждого раздела.
- Минусы:
  - Неэффективен, если таблица содержит много уникальных значений в столбце разбиения;
  - Может возникнуть проблема сбалансированности разделов, если данные не распределены равномерно по списку значений.

- **Секционирование по хэш-функции** (Hash partitioning): при таком секционировании таблица разбивается на разделы,
  основываясь на значениях хэш-функции определенного столбца. Например, можно разбить таблицу по хэшу идентификатора
  пользователя или по хэшу даты. Это позволяет распределять данные по разделам случайным образом и ускорять поиск
  данных.

- Плюсы:
  - Распределяет данные случайным образом между разделами, что может помочь балансировать нагрузку на сервере базы
    данных;
  - Позволяет быстро находить данные, если известно значение хэш-функции;
  - Эффективен для таблиц с большим количеством уникальных значений в столбце разбиения.
- Минусы:
  - Неэффективен для запросов, которые часто выполняются на конкретные значения столбца;
  - Неудобен для сортировки данных или выполнения запросов на основе диапазонов значений.

### Внешние таблицы

```sql
-- Создаем сервер для подключения к удаленной базе данных
CREATE SERVER my_server
FOREIGN DATA WRAPPER postgres_fdw -- Используем драйвер postgres_fdw для подключения к PostgreSQL серверу
OPTIONS (host 'remote_host', port '5432', dbname 'remote_db', user 'remote_user', password 'remote_password');

-- Сопоставление пользователей
CREATE USER MAPPING FOR local_user
SERVER my_server
OPTIONS (user 'remote_user', password 'remote_password');

-- Создаем внешнюю таблицу, связанную с таблицей "my_table" в удаленной базе данных
CREATE FOREIGN TABLE my_table (
  id INT,
  name TEXT,
  age INT
)
SERVER my_server -- Указываем, что таблица связана с сервером "my_server"
OPTIONS (schema_name 'public', table_name 'my_table');
```

В результате выполнения этого кода в вашей базе данных будет создана внешняя таблица с именем "my_table", которая
связана с таблицей "my_table" в удаленной базе данных на сервере "remote_host". Вы можете использовать стандартные
SQL-запросы, такие как SELECT, INSERT, UPDATE и DELETE, чтобы работать с данными в этой таблице, как если бы они были
локальными. Однако обратите внимание, что скорость работы может сильно зависеть от качества соединения с удаленной базой
данных, поэтому необходимо учитывать это при проектировании приложения.

Создавать сторонние таблицы могут пользователи, имеющие право USAGE для стороннего сервера и права USAGE для всех типов
столбцов создаваемой таблицы

### Представления

В PostgreSQL, **представление** (view) - это виртуальная таблица, которая не хранит данные непосредственно, но может
быть использована как обычная таблица для выполнения запросов.

Представления могут быть полезны в тех случаях, когда нужно выполнить сложный запрос к нескольким таблицам или когда
нужно скрыть какие-то данные от пользователей или приложений, предоставляя только определенную информацию.

Создать представление в PostgreSQL можно с помощью команды CREATE VIEW. Например:

```sql
CREATE VIEW my_view AS SELECT column1, column2 FROM my_table WHERE column3 = 'value';
```

После создания представления, можно использовать его в запросах как обычную таблицу:

```sql
SELECT * FROM my_view;
```

Основное отличие между представлением и временной таблицей в PostgreSQL заключается в том, что представление является
виртуальной таблицей, которая не хранит данные непосредственно, а временная таблица - это реальная таблица, которая
хранит данные в течение сеанса соединения с базой данных.

**Материализованное представление** (materialized view) - это специальный тип представления, который фактически хранит
данные в виде таблицы. Таким образом, материализованные представления могут быть полезны в случаях, когда нужно
выполнить сложный запрос к нескольким таблицам, но данные в этих таблицах изменяются редко, и запрос может быть дорогим
в вычислительном отношении.

Создать материализованное представление в PostgreSQL можно с помощью команды CREATE MATERIALIZED VIEW. Например:

```sql
CREATE MATERIALIZED VIEW my_mat_view AS SELECT column1, column2 
FROM my_table WHERE column3 = 'value';
```

Для обновления данных в материализованном представлении нужно выполнить команду REFRESH MATERIALIZED VIEW. Например:

```sql
REFRESH MATERIALIZED VIEW my_mat_view;
```

Однако, следует помнить, что использование материализованных представлений может привести к увеличению занимаемого места
на диске и возможно потребуется периодически обновлять данные в представлении для того, чтобы они оставались
актуальными.
