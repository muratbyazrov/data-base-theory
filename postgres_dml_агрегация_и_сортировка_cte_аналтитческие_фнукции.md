## DML: агрегация и сортировка, CTE, аналитические функции

[К оглавлению...](/README.md)

### GROUP

- группировка - это схлопывание
    - если какие-то поля не могут быть объединены - группировки не будет

- группировка по одному полю + показать количество сгруппированных (схлопнутых) записей

```sql
SELECT staff, count(*)
FROM rent
GROUP BY staff
```

- группировка по двум полям + показать количество сгруппированных (схлопнутых)

```sql
SELECT staff, customer, count(*)
FROM rent
GROUP BY staff
```

- 1-ый и 2-ой запросы выше одним запросом

```sql
SELECT staff, customer, count(*)
FROM rent GROUPING SETS (staff, (staff, customer))
```

- группировка с условием

```sql
-- покажет уникальные staff и их количество, причем только те, у которых кол-во > 1
SELECT staff count(*)
FROM rent
GROUP BY staff
HAVING count(*) > 1
```

- `union` - объединение выборок (но схлопнет одинаковые выводы)
- `union all` - объединения выборок (покажет все как есть)

- есть ещё group by cube - все перекрестные вычисления (хз, надо смотреть че это)

Пример группировку по двум полям:

| Имя   | Пол | Возраст |
|-------|-----|---------|
| Анна  | Ж   | 20      |
| Марк  | М   | 19      |
| Джейн | Ж   | 20      |
| Джон  | М   | 19      |
| Петр  | М   | 20      |

| Пол | Возраст |
|-----|---------|
| Ж   | 20      |
| М   | 19      |
| М   | 20      |

### CTE (common table expression)

- по-русски: Обобщенные табличные выражения
- это запросы с `with`
    - материализовался до 12 версии
    - есть рекурсии (позволяет создавать запросы, которые могут итеративно обрабатывать данные, пока выполняется
      определенное условие)

- `OFFSET` - ресурсоемкий
    - Можно идти с конца, если необходимый кусок внизу

### Оконные функции

- Оконные функции представляют собой расширение стандартных агрегатных функций, таких как сумма, среднее или максимум,
  путем добавления дополнительного синтаксиса для определения окна, на котором выполняется вычисление

- Примеры использования
    - Вычисление относительных изменений
    - Вычисление скользящих сумм или средних значений
    - Ранжирование и нумерация строк
    - Вычисление накопительных значений

```sql
-- оконная функция
<функция> OVER ( [ <определение окна> ] )
```

```sql
-- или так
SELECT
  <функция>
FROM
  <таблица>
WINDOW <имя окна> AS ( [ <определение окна> ] )
```

```sql
-- определение окна
[ <название окна> ] -- необязательное имя, которое можно присвоить окну
[ PARTITION BY <выражение> [, ...] ] -- определяет разделение строк на группы по заданному выражению
[ ORDER BY <выражение> [ ASC | DESC ] [, ...] ] -- определяет порядок сортировки строк внутри каждой группы окна
[ <фрейм> ] --  определяет границы окна, т.е. какие строки будут включены в окно для вычисления. Фрейм может быть определен с помощью следующих ключевых слов: ROWS BETWEEN, RANGE BETWEEN или GROUPS BETWEEN
```

- Примеры оконных функций в PostgreSQL
    - `ROW_NUMBER` - Присваивает уникальный номер каждой строке в результате запроса
    - `RANK`
    - `DENSE_RANK`
    - `LAG` - Возвращает значение из предыдущей строки в указанной колонке (можно `n` значений назад)
    - `LEAD` - Возвращает значение из следующей строки в указанной колонке
    - `SUM` - Вычисляет сумму значений в указанной колонке
    - `AVG` - Вычисляет среднее значение в указанной колонке
    - `COUNT` - Подсчитывает количество строк в результате запроса или количество непустых значений в указанной колонке
    - `first_value` - Первое значение в окне
    - `last_value` - Последнее значение в окне
    - `nth_value` - n-ое значение в окне
    - `COUNT` - Подсчитывает количество строк в результате запроса или количество непустых значений в указанной колонке
    - есть и другие

- можно создавать свои оконные функции (CREATE WINDOW FUNCTION)
- можно делить окна на группы с помощью partition (нет, это не те самые партиции)
- Оконные функции обычно применяются вместе с ключевым словом OVER, которое указывает на определенное окно или набор
  строк, над которыми должна быть выполнена функция.

```sql
-- В этом примере используются две оконные функции: AVG() для вычисления средней зарплаты в каждом отделе (сгруппированном по department_id) и ROW_NUMBER() для нумерации строк по убыванию зарплаты
SELECT
  employee_id,
  last_name,
  salary,
  AVG(salary) OVER (PARTITION BY department_id) AS avg_salary,
  ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_number
FROM
  employees;
```

- `RANK` и `DENSE_RANK` - это ранжирование
    - PostgreSQL сначала упорядочивает строки в результате запроса на основе указанного порядка сортировки
    - Затем каждой строке присваивается ранг, который обозначает ее позицию в упорядоченном списке
- Например, если у вас есть таблица с оценками студентов, функция RANK может присвоить ранг каждой оценке
- если две строки имеют одинаковые значения и должны получить одинаковый ранг, следующая строка получит ранг,
  увеличенный на количество пропущенных значений
- `DENSE_RANK` отличается только тем, что следующая строчка получит ранг увеличенный не на количество пропущенных
  значений, а на 1 (то есть последовательно)

### crosstabl

- нужно для создания сводных таблиц
- к примеру, есть вот такая таблица

| client_id | product_name | sale_date    | quantity |
|-----------|--------------|--------------|----------|
| 1         | 'Product A'  | '2023-07-01' | 10       |
| 1         | 'Product B'  | '2023-07-01' | 5        |
| 1         | 'Product A'  | '2023-07-02' | 8        |
| 2         | 'Product A'  | '2023-07-01' | 15       |
| 2         | 'Product C'  | '2023-07-03' | 20       |

- из нее можно сделать такой вывод

| client_id | 2023-07-01 | 2023-07-02 | 2023-07-03 |
|-----------|------------|------------|------------|
| 1         | 15         | 8          | 0          |
| 2         | 15         | 0          | 20         |

- с помощью запроса 

```sql
SELECT *
FROM crosstab(
    'SELECT client_id, sale_date, SUM(quantity)
     FROM sales
     GROUP BY client_id, sale_date
     ORDER BY 1,2',
     
     'SELECT DISTINCT sale_date FROM sales ORDER BY 1'
) AS ct (client_id integer, "2023-07-01" integer, "2023-07-02" integer, "2023-07-03" integer);
```

Ну а подробнее надо читать в доке. Тут просто про то, что такое вообще можно делать