## DML: агрегация и сортировка, CTE, аналитические функции

[К оглавлению...](/README.md)

### GROUP

- группировка - это схлопывание
    - если какие-то поля не могут быть объединены - группировки не будет

- группировка по одному полю + показать количество сгруппированных (схлопнутых) записей

```sql
SELECT staff, count(*)
FROM rent
GROUP BY staff
```

- группировка по двум полям + показать количество сгруппированных (схлопнутых)

```sql
SELECT staff, customer, count(*)
FROM rent
GROUP BY staff
```

- 1-ый и 2-ой запросы выше одним запросом

```sql
SELECT staff, customer, count(*)
FROM rent GROUPING SETS (staff, (staff, customer))
```

- группировка с условием

```sql
-- покажет уникальные staff и их количество, причем только те, у которых кол-во > 1
SELECT staff count(*)
FROM rent
GROUP BY staff
HAVING count(*) > 1
```

- `union` - объединение выборок (но схлопнет одинаковые выводы)
- `union all` - объединения выборок (покажет все как есть)

- есть ещё group by cube - все перекрестные вычисления (хз, надо смотреть че это)

Пример группировку по двум полям:

| Имя   | Пол | Возраст |
|-------|-----|---------|
| Анна  | Ж   | 20      |
| Марк  | М   | 19      |
| Джейн | Ж   | 20      |
| Джон  | М   | 19      |
| Петр  | М   | 20      |

| Пол | Возраст |
|-----|---------|
| Ж   | 20      |
| М   | 19      |
| М   | 20      |

### CTE (common table expression)

- по-русски: Обобщенные табличные выражения
- это запросы с `with`
    - материализовался до 12 версии
    - есть рекурсии (позволяет создавать запросы, которые могут итеративно обрабатывать данные, пока выполняется
      определенное условие)

- `OFFSET` - ресурсоемкий
    - Можно идти с конца, если необходимый кусок внизу

### Оконные функции

- Оконные функции представляют собой расширение стандартных агрегатных функций, таких как сумма, среднее или максимум,
  путем добавления дополнительного синтаксиса для определения окна, на котором выполняется вычисление

- Примеры использования
    - Вычисление относительных изменений
    - Вычисление скользящих сумм или средних значений
    - Ранжирование и нумерация строк
    - Вычисление накопительных значений

```sql
-- оконная функция
<функция> OVER ( [ <определение окна> ] )
```

```sql
-- или так
SELECT
  <функция>
FROM
  <таблица>
WINDOW <имя окна> AS ( [ <определение окна> ] )
```

```sql
-- определение окна
[ <название окна> ] -- необязательное имя, которое можно присвоить окну
[ PARTITION BY <выражение> [, ...] ] -- определяет разделение строк на группы по заданному выражению
[ ORDER BY <выражение> [ ASC | DESC ] [, ...] ] -- определяет порядок сортировки строк внутри каждой группы окна
[ <фрейм> ] --  определяет границы окна, т.е. какие строки будут включены в окно для вычисления. Фрейм может быть определен с помощью следующих ключевых слов: ROWS BETWEEN, RANGE BETWEEN или GROUPS BETWEEN
```

- Примеры оконных функций в PostgreSQL
    - `ROW_NUMBER` - Присваивает уникальный номер каждой строке в результате запроса
    - `RANK`
    - `DENSE_RANK`
    - `LAG` - Возвращает значение из предыдущей строки в указанной колонке (можно `n` значений назад)
    - `LEAD` - Возвращает значение из следующей строки в указанной колонке
    - `SUM` - Вычисляет сумму значений в указанной колонке
    - `AVG` - Вычисляет среднее значение в указанной колонке
    - `COUNT` - Подсчитывает количество строк в результате запроса или количество непустых значений в указанной колонке
    - `first_value` - Первое значение в окне
    - `last_value` - Последнее значение в окне
    - `nth_value` - n-ое значение в окне
    - `COUNT` - Подсчитывает количество строк в результате запроса или количество непустых значений в указанной колонке
    - есть и другие

- можно создавать свои оконные функции (CREATE WINDOW FUNCTION)
- можно делить окна на группы с помощью partition (нет, это не те самые партиции)
- Оконные функции обычно применяются вместе с ключевым словом OVER, которое указывает на определенное окно или набор
  строк, над которыми должна быть выполнена функция.

```sql
-- Этот запрос пронумерует строки в таблице employees в порядке убывания зарплаты и вернет столбцы name, salary и rank.
SELECT name, salary, ROW_NUMBER() OVER (ORDER BY salary DESC) as rank
FROM employees;
```

- `RANK` и `DENSE_RANK` - это ранжирование
    - PostgreSQL сначала упорядочивает строки в результате запроса на основе указанного порядка сортировки
    - Затем каждой строке присваивается ранг, который обозначает ее позицию в упорядоченном списке
- Например, если у вас есть таблица с оценками студентов, функция RANK может присвоить ранг каждой оценке
- если две строки имеют одинаковые значения и должны получить одинаковый ранг, следующая строка получит ранг,
  увеличенный на количество пропущенных значений
- `DENSE_RANK` отличается только тем, что следующая строчка получит ранг увеличенный не на количество пропущенных
  значений, а на 1 (то есть последовательно)

```sql
SELECT name, score, RANK() OVER (ORDER BY score DESC) AS rank
FROM students;
```
