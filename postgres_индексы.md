## ИНДЕКСЫ

[К оглавлению...](/README.md)

### Упрощенная схема устройства БД

<img src='./images/12.png' width=700 height=150>

Бутылочное горлышко БД — это ввод-вывод. Надо стараться, чтобы обращений к диску было минимум

<img src='./images/13.png' width=700 height=300>

<img src='./images/14.png' width=700 height=300>

- Очень мало уровней
- Все результаты находятся на одном (нижнем) уровне и напрямую связаны между собой
- Это позволяет быстро искать как конкретные значения, так и диапазоны
- Алгоритмическая сложность: O(log n)

### Теперь конкретно про индексы

- нужны для повышения производительности чтения, сортировки, группировки…
- модифицируются при каждой операции INSERT, UPDATE, DELETE
- требуют дополнительного места на диске
- бывают нескольких разных видов (основной — B-Tree)

### Создание индекса

```sql
CREATE INDEX idx_offers_area
ON offers(area);
```

рекомендуется название вида idx_table_fields

### Как узнать цену запроса

```sql
EXPLAIN
SELECT name
FROM offers
WHERE area = 90;
```

- первое число cost – стоимость первой строки результата
- второе число cost – стоимость всех строк результата
- оценка даётся в условных единицах
- в ответе будет упомянут Index Scan (если нет, индекс не использовался)
- в ходе разработки можно сбрасывать кэш планировщика (для точности)

```sql
ANALYZE offers; 
```

### Составные индексы

- создаются сразу для нескольких полей
- в ряде случаев работают быстрее, чем несколько простых индексов
- могут "подхватываться" вместо простых индексов, если поля запроса находятся в левой части индекса*
- очень важно заранее подобрать нужный порядок полей в таком индексе

**Кардинальность** - Это то, насколько у нас много разных значений в столбце таблицы. Чем разнообразнее наши данные, тем
выше кардинальность.

<img src='./images/15.png' width=400 height=100>

- В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN.
- Составные индексы по нескольким полям работают и отдельно для этих полей.
- Существуют частично-составные индексы. Для работы такого индекса необходимо передавать все поля, входящие в индекс.
  Отдельно работать не будут. Пример частично-составные индекса:

```sql
  "receipts_mt_id_chunk_id_ukey" UNIQUE, btree (transaction_id, chunk_id) WHERE chunk_id IS NOT NULL
  "receipts_mt_id_chunk_null_ukey" UNIQUE, btree (transaction_id) WHERE chunk_id IS NULL 
```

### Кардинальность поля

```sql
SELECT COUNT(DISTINCT region)
FROM offers;
```

**Составные индексы: порядок полей**:

- в начало ставим поля с высокой кардинальностью (много разных значений)
- в конец ставим поля, по которым нужен поиск по диапазону

**Как создать составной индекс?**

```sql
CREATE INDEX idx_offers_area_region
ON offers(area, region);
```

### Практические советы

- индексы дают максимальный выигрыш для полей с высокой кардинальностью (много разных значений)
- для небольших таблиц индексы обычно не нужны (и часто игнорируются)
- нужно периодически анализировать запросы и удалять индексы, если они не используются

Индексы ещё бывают:

- Покрывающие: Хранят в себе значения полей, нужных запросу
- Фильтрованные: Создаются по условию WHERE, экономят место
- По функциям: Упрощают поиск (например, lower())
- Полнотекстовые: Разбивают текст на слова

Индекс в базе данных - это структура данных, которая позволяет быстро и эффективно находить записи в таблице, используя
определенный ключ или набор ключей.  
Индексы нужны для ускорения запросов. С индексами системе не надо сканировать всю таблицу для поиска нужного
совпадения.  
PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. По умолчанию тип индекса
B-дерево.  
Индексы можно создавать и удалять в любое время.

### Простые индексы

Простой индекс - это индекс на одном столбце таблицы. Он используется для ускорения операций выборки данных, сортировки
и группировки по этому столбцу.

### Необходимость и избыточность

Использование индексов является необходимым, если таблица содержит большое количество данных и выполнение операций
выборки данных становится слишком медленным. Однако, создание избыточных индексов может привести к ухудшению
производительности базы данных, так как при изменении данных таблицы индексы также должны быть обновлены. Поэтому
необходимо тщательно анализировать, какие индексы нужны и на каких столбцах они должны быть созданы.
