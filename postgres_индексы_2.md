## ИНДЕКСЫ 2

[К оглавлению...](/README.md)

- индексы физически хранятся и имеют размер

- за
  - select, update, delete - быстрее
  - сортировка быстрее
  - при выборке данных только индексного поля, данные из таблицы не выбираются

- против
  - требуют места (скажем, таблица весит 300 мб, то индекс от primary key будет весить 90 мб)
  - insert дольше
  - если индексов много, оптимизатор долго выбирает, че выбрать

### Типы индексов

- есть типы индексов, самый популярный - сбалансированное дерево
- для тестов у postgres_pro есть [тестовая база](https://postgrespro.ru/education/demodb) перелетов по россии:

- b-дерево
  - используется для типов, которые можно сортировать
  - для операторов сравнения
  - is null / not null
  - для LIKE там какие-то особенности
- хэш-индексы
  - работает только с условен равенства
  - преобразует текст в число с помощью хэш-функции и сравнивает
  - не работает с is null / not null
- gist
  - для специфических данных (например, геометрия)
- gin
  - для типов с ключами (массивы, jsonb)
  - когда запросы ищут значения в этих типах

- gin и gist можно использовать так же для полнотекстового поиска 

### Виды сканирования таблиц

- Seq Scan - послед сканирования от начала таблицы до искомого
- Index Scan (индекс хранит указатель на строку, стало быть ищем в индексе, возвращаем по указателю)
- Index only scan - обращения к таблице не происходит - вся инфа есть в индексе (не все типы индексов поддерживают)

### Создание индексов

- создание индекса на работающей таблице привесить к **блокировке** таблицы
- можно создать неблокирующий индекс `concurrently` - дольше создается (удаление тоже)
- есть индексы по выражениям
  - короче, вместо самого поля указываешь какую-нить функцию, которая делает что-то с полем (lower(column_name))
  - страдает скорость
  - можно свои функции использовать (ток, чтобы они возвращали одно значение)

- Есть **частичный** индекс и **составной**
  - Составной - по нескольким полям
  - Частичный - строится на подмножестве строк, который определятся условным выражением where

- Есть **покрывающие** индексы - они содержат все столбцы, необходимые для выполнения запроса, без необходимости обращения к
  самим строкам таблицы
  - будет использоваться Index only scan

### Другое

- можно запросом узнать размер таблицы с индексами или без
